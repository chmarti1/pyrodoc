<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>API | PYroMat</title>
    <link rel="stylesheet" type="text/css" href="./pyromat.css">
    <meta name="description" content="thermodynamic properties in python">
    <meta name="keywords" content="python,thermo,thermodynamic,property,properties">
    <meta name="author" content="C.R. Martin">
</head>
<body>

<iframe name="menu" id="menu" src="menu.html"></iframe>


<div id="content">
<div class="title">
    <h1>PYroMat API Documentation</h1>
</div>

<div id="toc" class=section>
    <div class="toc0"><a href="#structure">Package structure</a></div>
    <div class="toc0"><a href="#if">Interface layer</a></div>
        <div class="toc1"><a href="#if_get">get() and info()</a></div>
        <div class="toc1"><a href="#if_config">config[]</a></div>
    <div class="toc0"><a href="#import">The import process</a></div>
        <div class="toc1"><a href="#import_config">Loading the configuration</a></div>
        <div class="toc1"><a href="#import_reg">Populating the registry</a></div>
        <div class="toc1"><a href="#import_dat">Populating the data dictionary</a></div>
    <div class="toc0"><a href="#be">Back-end layer</a></div>
        <div class="toc1"><a href="#be_reg">reg</a></div>
        <div class="toc1"><a href="#be_dat">dat</a></div>
        <div class="toc1"><a href="#be_units">units</a></div>
        <div class="toc1"><a href="#be_utility">utility</a></div>
    <div class="toc0"><a href="#ig">The ideal gas collection</a></div>
        <div class="toc1"><a href="#ig_ig">Ideal gas (ig)</a></div>
        <div class="toc1"><a href="#ig_igmix">Ideal gas mixture (igmix)</a></div>
    <div class="toc0"><a href="#mp">The multi-phase collection</a></div>
        <div class="toc1"><a href="#mp_if97">Steam (if97)</a></div>
</div>

<h3 id="structure" class="subtitle">Package structure</h3>
<div class="section">
    <p>
    The PYroMat package is constructed in two layers, with the user- or command-line layer forming the top and most powerful layer.  The base PYroMat modules provides a minimalist interface to the more sophisticated back-end.
    </p>
    <div class="figure">
    <img width="100%" src="./fig/package.png" alt="Package Structure"></img>
    Figure 1: The PYroMat package structure
    </div>
    <p>
    When a user calls for an object like "ig.N2" (see the <a href="doc_intro.html">tutorial</a>), the <span class="code">get()</span> function reaches into the <span class="code">dat</span> module to see if PYroMat has any entries that match the ID the user requested.
    </p>
    <p>
    All of the jobs needed to get the package to the point where such a thing is possible are parsed out to the various back-end layer modules.  The <span class="code">dat</span> module is responsible for seeking out data files, loading them, and associating them with the correct data object in its <span class="code">data</span> dictionary.
    </p>
    <p>
    The <span class="code">reg</span> module is responsible for seeking out python files that might contain PYroMat object class definitions.  Candidate files are compiled and executed in their own name space.  Any class definitions that are children of the PYroMat <span class="code">__basedata__</span> prototype class are added to the <span class="code">registry</span> dictionary where the <span class="code">dat</span> module can find them.
    </p>
    <p>
    The <span class="code">units</span> module's purpose is pretty self-explanatory, but its implementation is not.  It holds a collection of funcitons that are named for the types of unit conversions they can perform.  These functions are made special because they are aware of PYroMat's unit configuration options.  Users who want to see what options are available should call up the <span class="code">units.show()</span> function.  This module also has a collection of useful constants like the Boltzmann constant (<span class="code">const_k</span>), the universal gas constant (<span class="code">const_Ru</span>), and others.
    </p>
    <p>
    Finally, the <span class="code">utility</span> module is a catch-all for every function, exception, class, and other miscelania that the package needs to operate.  That includes the configuration class on which the <span class="code">config</span> object is built, all exceptions, and file handling functions for loading, testing, and maintaining the data files.
    </p>
    <a href="#toc">Top</a>
</div>

<h3 id="if" class="subtitle">Interface layer</h3>
<div class="section">
    <p>
    The vast majority of functionality a typical user will need is provided in the user layer by the individual <a href=#obj>data objects</a>.  The interface layer is only responsible for querying and retrieving those objects.
    </p>
    <h3 id="if_get">get() and info()</h3>
        <p>
        For the time being, there are only two functions that are used for interacting with the PYroMat data objects; <span class="code">get()</span> and <span class="code">info()</span>.  When called with no arguments, the <span class="code">info()</span> function prints a table of the IDs for all the available data objects.  If called with the ID string of one of those objects, the <span class="code">info()</span> function prints documentation for the object.  Usually this will include a description of the object and citations for the data source.
        </p>
        <p>
        By far the most important member of the interface layer, the <span class="code">get()</span> function retrieves the data objects.  Really, a call to <span class="code">get(idstring)</span> is quite similar to <span class="code">pyromat.dat.data[idstring]</span>, but with some graceful error handling.
        </p>
    <h3 id="if_config">config[]</h3>
        <p>
        The configuration object, <span class="code">config</span>, manages all of the user-configurable behaviors of PYroMat.  That includes how data are loaded, which units should be used, and what temperature-pressure defaults should be used.  The <span class="code">config</span> object is an instance of the <span class="code">PMConfig</span> class and its entries are all <span class="code">PMConfigEntry</span> instances; both classes provided in <a href="#be_utility">utility</a> module.
        </p>
        <p>
        The <span class="code">config</span> object is a wrapper for a dictionary, but with algorithms for building itself from user-written configuration files with built-in default values and with rules on acceptable values for each entry.  Entries remember whether they are read-only, they always remember their default values, and they raise exceptions if they are written with illegal values.  A complete list of the available configuration options and their current values is obtained simply be evoking the <span class="code">config</span> object at the command line.
        </p>
        <pre class="code">
>>> pm.config
     config_file : ['/home/chris/Documents/PYroMat/pyromat/defaults.py']
  config_verbose : False
         dat_dir : ['/home/chris/Documents/PYroMat/pyromat/data']
 dat_exist_fatal : False
   dat_overwrite : True
   dat_recursive : True
     dat_verbose : False
           def_T : 298.15
           def_p : 1.01325
     install_dir : '/home/chris/Documents/PYroMat/pyromat'
         reg_dir : ['/home/chris/Documents/PYroMat/pyromat/registry']
 reg_exist_fatal : False
   reg_overwrite : True
     reg_verbose : False
     unit_energy : 'kJ'
      unit_force : 'N'
     unit_length : 'm'
       unit_mass : 'kg'
     unit_matter : 'kg'
      unit_molar : 'kmol'
   unit_pressure : 'bar'
unit_temperature : 'K'
       unit_time : 's'
     unit_volume : 'm3'
         version : '2.0.1'</pre>
        <p>
        The configuration entries are organized into several groups based on how they are used.  For example, entries beginning with <span class="code">reg_</span> and <span class="code">dat_</span> determine how <a href="#be_reg">class definitions</a> and <a href="#be_dat">data files</a> are loaded.  Entries beginning with <span class="code">unit_</span> specify the default units to be used by the <a href="#be_units">units</a> module.  <span class="code">def_T</span> and <span class="code">def_p</span> indicate the default temperature and pressure to be used by property methods when the arguments are omitted.
        </p>
        <p>
        Some entries are read-only.
        </p>
        <pre class="code">
>>> import pyromat as pm
>>> pm.config['version']
'2.0.1'
>>> pm.config['version'] = 42
PYroMat ERR:: Failed to write to configuration parameter, 'version'
(<class 'pyromat.utility.PMParamError'>, PMParamError('Entry is read-only.',), <traceback object at 0x7f30e5f7ca28>)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "pyromat/utility.py", line 347, in __setitem__
    raise sys.exc_info()[1]
pyromat.utility.PMParamError: Entry is read-only.</pre>
        <p>
        Entries are data-type specific.
        </p>
        <pre class="code">
>>> pm.config['def_T']
298.15
>>> pm.config['def_T'] = 300.
>>> pm.config['def_T']
300.0
>>> pm.config['def_T'] = 'This is NOT a temperature'
PYroMat ERR:: Failed to write to configuration parameter, 'def_T'
(<class 'pyromat.utility.PMParamError'>, PMParamError("Expected <type 'float'>, but got 'This is NOT a temperature'",), <traceback object at 0x7f30e5f7c9e0>)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "pyromat/utility.py", line 347, in __setitem__
    raise sys.exc_info()[1]
pyromat.utility.PMParamError: Expected <type 'float'>, but got 'This is NOT a temperature'</pre>
        <p>
        And some entries behave a little strangely when they're written to.  Instead of overwriting the old value, new values are appended to a list.  These are usually lists of directories or files where PYroMat should search for data.  They can be reset to safe defaults using the <span class="code">restore_default()</span> method.
        </p>
        <pre class="code">
>>> pm.config['config_file']
['/home/chris/Documents/PYroMat/pyromat/defaults.py']
>>> pm.config['config_file'] = '/etc/pyromat/pyromat.py'
>>> pm.config['config_file']
['/home/chris/Documents/PYroMat/pyromat/defaults.py', '/etc/pyromat/pyromat.py']
>>> pm.config.restore_default('config_file')
>>> pm.config['config_file']
['/home/chris/Documents/PYroMat/pyromat/defaults.py']</pre>
    <p>
    Changes that are made in scripts and at the command line are lost when a user exists Python.  To make changes persistent, they should be placed in a configuration file.  The configuration process is described in detail <a href="#import_config">below</a>.
    </p>

    <a href="#toc">Top</a>
</div>


<h3 id="import" class="subtitle">The import process</h3>
<div class="section">
    <p>
    When PYroMat is imported for the first time, the package goes through a series of steps to build up its capabilities from nothing.  At its core, PYroMat doesn't know the first thing about substances of any kind.  For each substance, there is a file somewhere that provides all the necessary property data and names a class in the PYroMat "registry" with the methods for interpreting the data.  In the same way, there is a file somewhere that contains the definition for each class in the registry.
    </p>
    <p>
    Where do those files exist?  In what order should they be loaded?  What happens if there are redundant definitions?  How do users add their own files without having administrator priviledges?  All of these questions and more are addressed by the PYroMat configuration system.
    </p>

    <h3 id="import_config">Loading the configuration</h3>
    <p>
    The whole process begins with loading the system's configuration files.  Just like lots of other configuration systems, PYroMat uses parameter-value pairs.  Instead of using some other syntax, PYroMat configuration files are just Python scripts.  All variables defined in the local name space are written to the configuration object, <span class="code">config</span>.  Any variables that are not recognized PYroMat configuration directives will result in an error, and so will illegal values.
    </p>
    <p>
    When PYroMat begins its own import process, it is aware of a single configuration file, "defaults.py," in the PYroMat installation directory.  It is always loaded first, and it allows administrators to specify additional places to look for configuration files (like in users' home directories).
    </p>
    <p>
    The <span class="code">config_file</span> directive is one of several that append new values to a list rather than overwriting the old value, so each time a configuration file contains a <span class="code">config_file</span> directive, the list of files grows.  Even though the initial list contained only a single file, the configuration's <span class="code">load()</span> method continues recursively until the growing list is finally exhausted.  The savvy reader might worry about accidentally creating an endless cyclic references.  Good for you!  The configuration system maintains a list of all the files it has loaded and checks each file against the list.  No file will be loaded twice.
    </p>
    <p>
    For example, on a Unix system, an administrator might want to set up a configuration script in <span class="code">/etc</span>.  This line should be added to the "defaults.py" file: <span class="code">config_file = '/etc/pyromat.py'</span>.  Then, to allow users to write their own configurations (maybe you have some people who like different unit systems), that file might look something like this:
    </p>
    <pre class="code">
# PYroMat configuration file
#/etc/pyromat.py

# Multiple entries should appear in a list
# Note that environment variables work
config_file = ['/home/$USER/.pyromat/config.py', '/home/$USER/.pyromat.py']

# Note that the ~ symbol in Unix is also supported
dat_dir = '~/.pyromat/data'

# Of course, explicit definitions work too
reg_dir = '/usr/share/pyromat/reg'</pre>
    <p>
    It is important to note that if a directive is overwritten within the same script, then the rules about appending values will not be applied.  These are only used to join the values found in the different configuration files.  In the above example, <span class="code">config_file</span> is written with a list value in order to add two entries at once.
    </p>
    <p>
    For detailed documentation on all the configuration directives, read the comments in the "defaults.py" file.
    </p>

    <h3 id="import_reg">Populating the registry</h3>
    <p>
    The registry is where all the class definitions reside.  The <span class="code">reg</span> module has a function called <span class="code">regload()</span> that is responsible for seeking out the contents of all the directories identified by the <span class="code">reg_dir</span> configuration directive.  Like the <span class="code">config_file</span> directive, it accumulates values from all configuration files.
    </p>
    <p>
    Unlike configuration files, class definition files do not need to be called out by name.  Instead, they only need to be placed in one of the directories named in <span class="code">reg_dir</span>.  The file name must have a .py extension, and all files with an underscore "_" or a dot "." prefix in their name are ignored.  Files that meet these criteria are compiled and executed.  All objects that are <span class="code">type</span> instances and are subclasses of the <span class="code">reg.__base_data__</span> class are incorporated into the <span class="code">reg.registry</span> dictionary.
    </p>
    <p>
    In this documentation, "the registry" refers to that dictionary of classes.  They keys to the dictionary are the names of the classes they define.  This is important because the class name is called out by each data file.
    </p>
    <p>
    There are three True/False-valued configuration options that affect the behavior of the registry: <span class="code">reg_verbose</span>, <span class="code">reg_overwrite</span>, and <span class="code">reg_exist_fatal</span>.  When set to True <span class="code">reg_verbose</span> prompts <span class="code">reg.regload()</span> to print its behavior to stdout, which can be helpful for debugging.
    </p>
    <p>
    The latter two deal with file precedence in the case of a redundant definition.  When True, <span class="code">reg_overwrite</span> a class definition that is named identically with one already loaded will replace its predecessor.  Otherwise, the first loaded receives preference.  If there is a redundant definition when <span class="code">reg_exist_fatal</span> is True, the load process will fail with a <span class="code">PMFileError</span> exception.
    </p>
    <p>
    For multiple reasons, the registry construction process never recurses into sub-directories.  First of all, registries do not usually require many files, and permitting complicated directory structures is not really necessary.  The real reason recursion is not supported is to force users to be extremely deliberate about the codes they intend to include in the registry.
    </p>
    <p>
    Valid PYroMat data classes must have initializers that accept a data dictionary as a single argument.  What the class chooses to do with those data are up to it, but they are passed on from the data file load process.
    </p>

    <h3 id="import_dat">Populating the data dictionary</h3>
    <p>
    Just like the registry load process populates the registry with class definitions, the data load process populates a dictionary, <span class="code">dat.data</span> with all the individual species objects defined in the PYroMat system.
    </p>
    <p>
    Each data file defines the properties of a single species in a JavaScript Object Notation (JSON) format.  All data files must have the extension *.hpd, which is a throwback to the package's 2014 working title: Hot Python Data.  While the content and meaning of the individual data elements are entirely up to the class, PYroMat requires several elements to be defined in the resulting dictionary.
    </p>
    <p>
    Each data file must define a value, <span class="code">id</span>, which is the key that will be used to recognize the data object in the data dictionary.  Each file must have a string <span class="code">class</span> value, which will be used to call an element of <span class="code">reg.registry</span> to create the data object.  Finally, each file must define <span class="code">doc</span>, which is a long string used to supply a description of the species source data.  After loading, each data dictionary is forced to have the <span class="code">fromfile</span> key, which indicates the absolute path to the original data file.
    </p>
    <p>
    While the actual data loading algorithm is more complicated, adding a data file looks something like this:
    </p>
    <pre class="code">
import json
import pyromat as pm
with open("mydata.hpd") as ff:
    new_data_dict = json.load(ff)
    new_data_class = pm.reg.registry[new_data_dict['class']]
    pm.dat.data[new_data_dict['id']] = new_data_class(new_data_dict)</pre>
    <p>
    For developers, the <span class="code">dat.load()</span> function has a number of additional documented features that can help with debugging.  In particular, files can be excluded by adding a tilde "~" after the *.hpd extension.  PYroMat will regard this as a "suppressed" data file; one that can be but is not currently included in the load process.
    </p>
    <p>
    The data loading process is controlled by four configuration parameters.  Like the registry load process, <span class="code">dat.load()</span> can be prompted to print its behavior to stdout when the <span class="code">dat_verbose</span> directive is set to True.  Similarly, there are <span class="code">dat_overwrite</span> and <span class="code">dat_exist_fatal</span> options to control precedence in the case of redundant definitions.  Unlike the registry, data file searches will recurse into subdirectories when the <span class="code">dat_recursive</span> directive is set to True.
    </p>
    <p>
    Once this process is complete, the package is fully functional.  The <span class="code">get()</span> function is little more than a wrapper for the <span class="code">dat.data</span> dictionary.
    </p>

    <a href="#toc">Top</a>
</div>


<h3 id="be" class="subtitle">Back-end layer</h3>
<div class="section">
    <h3 id="be_reg">reg</h3>
    <p>
    The <span class="code">reg</span> module is responsible for maintaining the <span class="code">registry</span>; a dictionary of PYroMat class definitions that provide users all the tools they need to interact with the species' data.  The <span class="code">reg</span> module provides three essential tools:
    </p>
    <ul>
        <li>The <span class="code">regload()</span> function</li>
        <li>The <span class="code">registry</span> dictionary</li>
        <li>The <span class="code">__basedata__</span> class definition</li>
    </ul>
    <p>
    The <span class="code">regload()</span> function is responsible for loading the basic class definitions used to spawn all the individual species' objects described in the <a href="#import_reg">import process</a>.  The function's behavior is determined by the <a href="if_config">configuration options</a> <span class="code">reg_dir</span>, <span class="code">reg_overwrite</span>, <span class="code">reg_exist_fatal</span>, and <span class="code">reg_verbose</span>.  Their behaviors are discussed with the <a href="#import_reg">import system</a>.  Each file found with a ".py" extension is compiled and executed in its own variable space, and any objects that are children of the <span class="code">__basedata__</span> class will be added to the registry.
    </p>
    <p>
    The <span class="code">registry</span> is the dictionary that contains all of the class definitions found by <span class="code">regload()</span>.  The key is the string <span class="code">__name__</span> of the class definition, and the value of each is the class object itself.
    </p>
    <p>
    The <span class="code">__basedata__</span> class must be a parent of all PYroMat class definitions.  It defines an initializer and a <span class="code">__basetest__()</span> member that does some VERY simple integrity checking on the data.  In earlier versions, <span class="code">__basedata__</span> also offered some tools for "vectorizing" data and a <span class="code">psolve</span> routine for property inversion, but these were depreciated in favor of other methods.  The most important member of <span class="code">__basedata__</span> is <span class="code">data</span>, which is the dictionary which is supposed to contain the species' data.
    </p>
    <p>
    By default, each class definition resides in its own appropriately named file in the "registry" directory.  Users who want to develop their own classes might want to change that by adding entries to the <span class="code">reg_dir</span> configuration directive.  Here is a minimalist custom class definition that references the <span class="code">__basedata__</span> class, and calls its <span class="code">__init__</span> method to do some things we will discuss in the next section.
    </p>
    <pre class="code">
import pyromat as pm
class MyClass(pm.reg.__baseclass__):
    def __init__(self, data):
        pm.reg.__baseclass__.__init__(self,data)</pre>

    <h3 id="be_dat">dat</h3>
    <p>
    The <span class="code">dat</span> module is responsible for maintaining the <span class="code">data</span> dictionary, which provides each of the individual species objects keyed by their species ID.  In addition to being able to load these objects, the <span class="code">dat</span> module offers tools to create, manipulate, and even save them.  In addition to the <span class="code">data</span> dictionary itself, the <span class="code">dat</span> module contains:
    </p>
    <table>
        <tr>
            <td><span class="code">load()</span></td>
            <td>Loads the PYroMat ".hpd" files into the <span class="code">data</span> dictionary.  If called with the <span class="code">check=True</span> option</span>, instead of populating <span class="code">data</span>, <span class="code">load()</span> will load files into a fresh dictionary, and perform a detailed comparison with the data currently in memory.</td>
        </tr>
        <tr>
            <td><span class="code">clear()</span></td>
            <td>Empties the <span class="code">data</span> dictionary.</td>
        </tr>
        <tr>
            <td><span class="code">new()</span></td>
            <td>Creates a new entry in the <span class="code">data</span> dictionary from a dictionary of raw data.  The dictionary must contain "id", "class", and "doc" keys, so that <span class="code">new()</span> will know how to store the object and with which class to associate it.  Otherwise, it must only conform to the rules of the class.</td>
        </tr>
        <tr>
            <td><span class="code">updatefiles()</span></td>
            <td>When run verbosely, this function inters an interactive dialogue to bring the files into agreement with the data currently in memory.  The idea is that users will be free to edit entries in the <span class="code">data</span> dictionary directly and the files can be automatically updated to make the changes permanent.</td>
        </tr>
    </table>
    <p>
    More detail is offered by the in-line help on each of these functions.
    </p>
    <p>
    When <span class="code">load</span> works its way through the <span class="code">dat_dir</span> list of directories looking for files with the ".hpd" extension, it uses the <a href="https://docs.python.org/2/library/json.html">json</a> module to load them.  The result is a dictionary with entries for each of the data elements defined in the file.  This dictionary is passed verbatim to the class initializer for each object, so that the creation of the oxygen object might appear:
    </p>
    <pre class="code">
>>> import pyromat as pm
>>> import json
>>> with open('O2.hpd','r') as ff:
...     data = json.load(ff)
...
>>> class = data['class']
>>> O2 = pm.reg.registry[class](data)</pre>
    <p>
    The behavior of <span class="code">load()</span> is defined by configuration directives, <span class="code">dat_dir</span>, <span class="code">dat_overwrite</span>, <span class="code">dat_exist_fatal</span>, and <span class="code">dat_verbose</span>.  These are described in more detail in the <a href="#import_dat">import system</a> section.
    </p>

    <h3 id="be_units">units</h3>
    <p>
    The unit conversion system uses a single class as the prototype for a collection of function-like objects that go between the various unit systems PYroMat recognizes.  The fastest way to see what is available is to call the <span class="code">show()</span> function.
    </p>
    <pre class="code">
>>> pm.units.show()
          force : lb lbf kN N oz kgf 
         energy : BTU kJ J cal eV kcal BTU_ISO 
    temperature : K R eV C F 
       pressure : mmHg psi inHg MPa inH2O kPa Pa bar atm GPa torr mmH2O ksi 
          molar : Ncum NL Nm3 kmol scf n mol sci Ncc lbmol 
         volume : cumm cc mL L mm3 in3 gal UKgal cuin ft3 cuft USgal m3 cum 
         length : ft nm cm mm m km um mile in 
           mass : mg kg g oz lb lbm slug 
           time : s ms min hr ns year day us </pre>
    <p>
    Each row is named for the <span class="code">Conversion</span> object that defines the units listed.  For example, in order to convert a force from 4.5 newtons to pounds,
    </p>
    <pre class="code">
>>> pm.units.force(4.5, from_units='N', to_units='lb')
1.0116402439486973</pre>
    <p>
    When the <span class="code">from_units</span> or <span class="code">to_units</span> keywords are omitted, then each of the <span class="code">Conversion</span> objects is linked to a configuration directive to use instead.  This is how the various PYroMat data classes convert to and from the user-specified unit systems.  For example, 
    </p>
    <pre class="code">
>>> pm.config['unit_force'] = 'N'
>>> pm.units.force(4.5, to_units='lb')
1.0116402439486973
>>> pm.units.force(1.0116402439486973, from_units='lb')
4.5</pre>
    <p>
    Of course, some conversions require multiple steps.  For example, molecular weight is specified in <span class="code">unit_mass</span> per <span class="code">unit_molar</span>.  To make that multi-step process easier, there is an optional <span class="code">exponent</span> keyword to indicate the unit's exponent in the unit cluster.
    </p>
    <pre class="code">
>>> O2mw = 32.  # kg / kmol
>>> O2mw = pm.units.mass(O2mw, from_units='kg', to_units='lbm')
>>> O2mw = pm.units.molar(O2mw, from_units='kmol', to_units='mol', exponent=-1)</pre>
    <p>
    This calculates molecular weight in pound-mass per mole; if you like that kind of thing.
    </p>
    <p>
    This behavior works for all nine (9) of the <span class="code">Conversion</span> instances above, but there are also two special cases: <span class="code">temperature_scale()</span> and <span class="code">matter()</span>.
    </p>
    <p>
    The <span class="code">temperature()</span> conversion tool will perform temperature conversions with the assumption that all temperatures are <it>relative</it> (i.e. a change in temperature).  For example, a 32-degree-Fahrenheit change in temperature is equivalent to a 17.8-degree-Celsius change, but 32F is NOT 17.8C.  This problem is addressed by the <span class="code">temperature_scale()</span> function, which has nearly the same call signature as <span class="code">temperature()</span>, but handles conversion between scales gracefully.
    </p>
    <pre class="code">
>>> pm.units.temperature(32., from_units="F", to_units="C")
17.77777777777778
>>> pm.units.temperature_scale(32., from_units="F", to_units="C")
0.0</pre>
    <p>
    The <span class="code">matter()</span> function is a different matter.  It requires the molecular weight of a substance, and it can convert between mass and molar units.  This is what PYroMat uses to handle intensive units like entropy, enthalpy, specific heat, etc.  It is linked to the <span class="code">unit_matter</span> configuration directive for its default behavior.
    </p>
    <pre class="code">
>>> pm.units.matter(1., mw=32., from_units="kmol", to_units="kg")
32.0
</pre>
    <p>
    The <span class="code">units</span> module also exposes a number of important constants on which it depends for its calculations.
    </p>
    <table>
        <tr>
            <td><span class="code">const_k</span></td>
            <td>Joule/Kelvin</td>
            <td>Boltzmann's constant</td>
        </tr>
        <tr>
            <td><span class="code">const_Na</span></td>
            <td>count/mole</td>
            <td>Avagadro's constant</td>
        </tr>
        <tr>
            <td><span class="code">const_Ru</span></td>
            <td>Joule/mole/Kelvin</td>
            <td>Universal gas constant</td>
        </tr>
        <tr>
            <td><span class="code">const_Tstd</span></td>
            <td>Kelvin</td>
            <td>Standard temperature for volumetric molar units</td>
        </tr>
        <tr>
            <td><span class="code">const_pstd</span></td>
            <td>bar</td>
            <td>Standard pressure for volumetric molar units</td>
        </tr>
        <tr>
            <td><span class="code">const_Nstd</span></td>
            <td>mole/cubic meter</td>
            <td>Standard number density for volumetric molar units</td>
        </tr>
        <tr>
            <td><span class="code">const_g</span></td>
            <td>meter/second<sup>2</sup></td>
            <td>Acceleration due to gravity</td>
        </tr>
        <tr>
            <td><span class="code">const_dh2o</span></td>
            <td>kg/meter<sup>3</sup></td>
            <td>Density of water used for column pressure</td>
        </tr>
        <tr>
            <td><span class="code">const_dhg</span></td>
            <td>kg/meter<sup>3</sup></td>
            <td>Density of mercury used for column pressure</td>
        </tr>
    </table>
    <p>
    These and all of their dependent <span class="code">Conversion</span> objects are initialized using the <span class="code">setup()</span> function when the module is first loaded.  To change any of these constants, see the <span class="code">setup()</span> in-line documentation.  Evoking it at the command line will re-define all of the dependent routines correctly.
    </p>

    <h3 id="be_utility">utility</h3>
    <p>
    Coming soon.  Move along, there's nothing to see here.  These aren't the documents you're looking for.  The cake is a lie.  Seriously, why do you want to read this anyway; I'm sure it would be really boring.  OK fine.  I'll get to it later.
    </p>
    <a href="#toc">Top</a>
</div>


<h3 id="ig" class="subtitle">Ideal gas collection (ig)</h3>
<div class="section">
    <p>
    The properties of all members of the ideal gas collection conform to several important assumptions:
    </p>
    <ul>
        <li>Specific heats (and therefore enthalpy) is not a function of pressure.</li>
        <li>Density is computed from temperature and pressure by the ideal gas equation (i.e. compressibility is 1).</li>
        <li>Isotopes of the substance can be neglected when calculating molecular weight.</li>
    </ul>
    <p>
    For properties like enthalpy and entropy that are defined in terms of integrals of specific heat, there is an arbitrary choice of integration constant.  These are usually selected so that a property will have a convenient value at a convenient state.  However, because of their importance to reaction modeling, these ideal gas properties are all standardized to permit the calculation of properties across chemical reactions.  
    </p>
    <p>
    All members of the ideal gas collection support an optional True/False parameter, <span class="code">hf</span>, to the enthalpy method, which allows users to disable the inclusion of the "enthalpy of formation."  When <span class="code">hf=False</span>, the enthalpy of the species will be calculated so that <span class="code">h(298.15, 1.)</span> is quite close to zero (in K and bar).  When <span class="code">hf=True</span> (the default) the enthalpy will include the energy released/consumed due to chemical reactions, and only a few so-called "reference species" will have zero enthalpy at standard conditions (i.e. N<sub>2</sub>, O<sub>2</sub>, H<sub>2</sub>, Ar, etc.).
    </p>
    <p>
All arguments and all returned values are translated according to the PYroMat unit configuration directives.  The in-line documentation for each method specifies which units directives are used to convert inputs and outputs.  It should be emphasized that specifying unit mass, unit length and unit time does NOT specify the unit energy.
    </p>

    <h3 id="ig_ig">Ideal gas (ig)</h3>
    <p>
    The ideal gas class is built on the so-called Shomate equation of state, which is used both by the <a href="http://webbook.nist.gov/chemistry/guide/#thermo-gas">NIST Webbook</a> and <a href="http://cantera.org/docs/sphinx/html/cython/thermo.html#shomatepoly2">Cantera</a> to calculate ideal gas properties.  It is a piece-wise five-term expansion for isobaric specific heat with a single non-polynomial term.  The ideal gas class provides properties:
    </p>
    <table cellpadding=10>
        <tr><td class="code">cp(T,p)</td>
            <td>isobar specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">cv(T,p)</td>
            <td>isochor specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">d(T,p)</td>
            <td>density</td>
            <td class="code">unit_matter / unit_volume</td>
        </tr>
        <tr><td class="code">e(T,p)</td>
            <td>internal energy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">h(T,p)</td>
            <td>enthalpy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">gam(T,p)</td>
            <td>specific heat ratio</td>
            <td>dimensionless</td>
        </tr>
        <tr><td class="code">mw()</td>
            <td>molecular weight</td>
            <td class="code">unit_mass / unit_molar</td>
        </tr>
        <tr><td class="code">R()</td>
            <td>gas constant</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">s(T,p)</td>
            <td>entropy</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
    </table>
There are also routines to invert properties; e.g. calculating 
temperature from enthalpy or from entropy and pressure.
    <table>
        <tr><td class="code">T_h(h,p)</td><td>temperature from enthalpy</td></tr>
        <tr><td class="code">T_d(d,p)</td><td>temperature from density and pressure</td></tr>
        <tr><td class="code">T_s(s,p)</td><td>temperature from entropy and pressure</td></tr>
        <tr><td class="code">p_s(s,T)</td><td>pressure from entropy and temperature</td></tr>
        <tr><td class="code">p_d(d,T)</td><td>pressure from density and temperature</td></tr>
    </table>
    <p>
    The method, <span class="code">Tlim()</span>, returns a two-element tuple with the min,max temperatures supported by the data set.
    </p>
    <p>
    These data are primarily useful at high temperatures, but the exact limits on the data are not consistent across species.  Some are limited by phase transitions, and others simply by the source data.  Each object reports its own limits using the <span class="code">Tlim()</span> method.  Calls to properties outside of these limits will result in an error.
    </p>
    <p>
    Finally, the <span class="code">contents()</span> method returns a dictionary that names the constituent atoms and their quantities in the species chemical formula.  It does this by parsing the species ID for upper-case letters followed by lower-case letters, followed by an optional integer quantity.  The result might look like <span class="code">{'C': 1, 'O': 2}</span> for carbon dioxide.
    </p>

    <h3 id="ig_igmix">Ideal gas mixture (igmix)</h3>
    <p>
    The ideal gas mixture class permits the calculation of properties of mixtures of ideal gases.  These data belong to the ideal gas collection because they follow all of the same rules, rest on the same physical assumptions, and are built on the same base data.  The <span class="code">igmix</span> methods work by combining the relevant member species' <span class="code">ig</span> methods in the appropriate weighted averages.
    </p>
    <p>
    The valid temperature range for ideal gas mixtures is limited by the range of which ALL constituents have valid data.  Some ideal gases (like diatomic oxygen) support low temperatures, but most do not.  As a result, mixtures that contain oxygen (like air) may not support the same broad range as each constituent.  For that reason, <span class="code">igmix</span> has its own <span class="code">Tlim()</span> method that reports the intersection of all the constituent species' temperature ranges.
    </p>
    <p>
    The <span class="code">igmix</span> class provides properties:
    </p>
    <table cellpadding=10>
        <tr><td class="code">cp(T,p)</td>
            <td>isobar specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">cv(T,p)</td>
            <td>isochor specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">d(T,p)</td>
            <td>density</td>
            <td class="code">unit_matter / unit_volume</td>
        </tr>
        <tr><td class="code">e(T,p)</td>
            <td>internal energy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">h(T,p)</td>
            <td>enthalpy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">gam(T,p)</td>
            <td>specific heat ratio</td>
            <td>dimensionless</td>
        </tr>
        <tr><td class="code">mw()</td>
            <td>molecular weight</td>
            <td class="code">unit_mass / unit_molar</td>
        </tr>
        <tr><td class="code">R()</td>
            <td>gas constant</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">s(T,p)</td>
            <td>entropy</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">X()</td>
            <td>mole fractions</td>
            <td>dimensionless</td>
        </tr>
        <tr><td class="code">Y()</td>
            <td>mass fractions</td>
            <td>dimensionless</td>
        </tr>
    </table>
    <p>
    The <span class="code">igmix</span> class provides inverse property routines:    
    </p>
    <table>
        <tr><td class="code">T_h(h,p)</td><td>temperature from enthalpy</td></tr>
        <tr><td class="code">T_s(s,p)</td><td>temperature from entropy and pressure</td></tr>
    </table>

    <a href="#toc">Top</a>
</div>


<h3 name="ig" class="subtitle">Multi-phase collection (mp)</h3>
    <div class="section">

    <p>
    The multi-phase collection is home to classes that support the calculation of species' properties across phase changes.  Unlike the ideal gas collection, the integration constants in these species do not include the enthalpies of formation.  
    </p>
    <h3 id="mp_if97">Steam class (if97)</h3>
    <p>
    The <a href="http://iapws.org/">International Association for the Properties of Water and Steam</a> issued the <a href="http://iapws.org/relguide/IF97-Rev.html">Industrial Formulation</a> for water's equation of state in 1997.  The report is abbreviated IAPWS-IF97, or IF97 for short, and has been widely adopted for applied use because it permits direct calculation of properties from temperature and pressure.  Many precise two-phase equations of state use <a href="http://iapws.org/relguide/IAPWS-95.html">temperature and density</a> to provide an elegant mathematical description of the phase change (which T,p does not permit).  However, in applications where temperature and pressure are known, this requires expensive iteration to invert the formulation.
    </p>
    <p>
    The <span class="code">if97</span> class implements the piece-wise polynomial fit for water and steam.  In addition to the basic properties like specific heats, enthalpy, entropy, and internal energy, <span class="code">if97</span> also includes special methods for evaluating properties along the saturation line.  Almost all of the properties accept or return quality, <span class="code">x</span>, as an optional parameter.  See the in-line documentation for a detailed description of each method.
    </p>
    <p>
    The <span class="code">if97</span> class provides the following properties:
    </p>
    <table cellpadding=10>
        <tr><td class="code">cp(T,p)</td>
            <td>isobar specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">cv(T,p)</td>
            <td>isochor specific heat</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">d(T,p)</td>
            <td>density</td>
            <td class="code">unit_matter / unit_volume</td>
        </tr>
        <tr><td class="code">ds(T,p)</td>
            <td>saturation density</td>
            <td class="code">unit_matter / unit_volume</td>
        </tr>
        <tr><td class="code">e(T,p)</td>
            <td>internal energy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">es(T,p)</td>
            <td>saturation energy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">h(T,p)</td>
            <td>enthalpy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">hs(T,p)</td>
            <td>saturation enthalpy</td>
            <td class="code">unit_energy / unit_matter</td>
        </tr>
        <tr><td class="code">hsd(T,p)</td>
            <td>enthalpy, entropy, density</td>
            <td>(see <span class="code">h</span>,<span class="code">s</span>, and <span class="code">d</span></td>
        </tr>
        <tr><td class="code">gam(T,p)</td>
            <td>specific heat ratio</td>
            <td>dimensionless</td>
        </tr>
        <tr><td class="code">mw()</td>
            <td>molecular weight</td>
            <td class="code">unit_mass / unit_molar</td>
        </tr>
        <tr><td class="code">s(T,p)</td>
            <td>entropy</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">ss(T,p)</td>
            <td>saturation entropy</td>
            <td class="code">unit_energy / unit_temperature / unit_matter</td>
        </tr>
        <tr><td class="code">Ts(p)</td>
            <td>saturation temperature</td>
            <td class="code">unit_temperature</td>
        </tr>
        <tr><td class="code">ps(T)</td>
            <td>saturation pressure</td>
            <td class="code">unit_pressure</td>
        </tr>
        <tr><td class="code">triple()</td>
            <td>triple point (T,p)</td>
            <td class="code">unit_temperature, unit_pressure</td>
        </tr>
        <tr><td class="code">critical()</td>
            <td>critical point (T,p)</td>
            <td class="code">unit_temperature, unit_pressure</td>
        </tr>
    </table>
    <p>
    The <span class="code">if97</span> provides inverse routines:
    </p>
    <table>
        <tr><td class="code">T_h(h,p)</td><td>temperature from enthalpy</td></tr>
        <tr><td class="code">T_s(s,p)</td><td>temperature from entropy and pressure</td></tr>
    </table>
    <p>
    The limits on the validity of the IF-97 class properties are reported by the <span class="code">plim()</span> and <span class="code">Tlim()</span> methods.  Since the IF-97 report equations are valid over piece-wise rectangles in T,p space, these functions accept temperature and pressure respectively as optional arguments.
    </p>


    <a href="#toc">Top</a>
</div>

<iframe src="author.html" id="contact"></iframe>

</div>
</body>
</html>
